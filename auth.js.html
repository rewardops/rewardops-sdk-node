

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> auth.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-api.html">api</a></li><li><a href="module-auth.html">auth</a></li><li><a href="module-config.html">config</a></li><li><a href="module-context.html">context</a></li><li><a href="module-emitter.html">emitter</a></li><li><a href="module-resources_custom-categories.html">resources/custom-categories</a></li><li><a href="module-resources_items.html">resources/items</a></li><li><a href="module-resources_members.html">resources/members</a></li><li><a href="module-resources_order-recipients.html">resources/order-recipients</a></li><li><a href="module-resources_orders.html">resources/orders</a></li><li><a href="module-resources_programs.html">resources/programs</a></li><li><a href="module-resources_rewards.html">resources/rewards</a></li><li><a href="module-resources_subsegments.html">resources/subsegments</a></li><li><a href="module-urls.html">urls</a></li><li><a href="module-utils_auth.html">utils/auth</a></li><li><a href="module-utils_axios.html">utils/axios</a></li><li><a href="module-utils_logger.html">utils/logger</a></li></ul><h3>Classes</h3><ul><li><a href="SDKError.html">SDKError</a></li></ul><h3>Global</h3><ul><li><a href="global.html#RO">RO</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>auth.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Authorization
 *
 * @module auth
 * @copyright 2015â€“2020 RewardOps Inc.
 */

const request = require('request');

const emitter = require('./emitter');
const urls = require('./urls');
const { generateBasicAuthToken } = require('./utils/auth');
const { log, processLogData } = require('./utils/logger');

/**
 * Token lock status
 *
 * @private
 */
let tokenLocked = false;

/**
 * URL path for the authorization token in the RewardOps API.
 *
 * @protected
 */
const TOKEN_PATH = '/token';

/**
 * Get status of authorization token lock.
 *
 * @returns {boolean} Returns token lock status
 *
 * @private
 */
const isTokenLocked = () => tokenLocked;

/**
 * Lock authorization token.
 *
 * @private
 */
function lockToken() {
  tokenLocked = true;
}

/**
 * Unlock authorization token.
 *
 * @private
 */
function unlockToken() {
  tokenLocked = false;
}

/**
 * Authorization token properties and actions object.
 *
 * @type {object}
 *
 * @property {{access_token: string, expires: Date}} token The current authorization token (retrieved from the API).
 * @property {Function} getBaseUrl Get the base URL for the RewardOps authorization token.
 * @property {Function} getTokenUrl Get the authorization token URL for the RewardOps API.
 * @property {Function} getTokenPath Get the value of `TOKEN_PATH`.
 * @property {Function} invalidateToken Invalidate (clear) the authorization token.
 * @property {getToken} getToken Get authorization token.
 */
const auth = {
  token: {},

  /**
   * @type {Function}
   *
   * @param {{ apiVersion: string, apiServerUrl: string }} config Both params are used to build the url
   *
   * @returns {string} Returns the hostname plus the auth path
   */
  getBaseUrl: config => `${urls.getApiBaseUrl(config)}/auth`,

  /**
   * @type {Function}
   *
   * @param {{ apiVersion: string, apiServerUrl: string }} config Both params are used to build the url
   *
   * @returns {string} Returns the complete token url
   */
  getTokenUrl(config) {
    return this.getBaseUrl(config) + TOKEN_PATH;
  },

  getTokenPath() {
    return TOKEN_PATH;
  },

  invalidateToken: () => {
    auth.token = {};
  },
};

/**
 * Safe request authorization token method.
 *
 * If the initial responses have errors, a retry strategy is employed.
 *
 * @param {object} requestOptions Options for a [Request]{@link https://github.com/request/request} POST call.
 * @param {{attempts: number, maxAttempts: number}} retryStrategy Request retry strategy options.
 * @param {module:api~requestCallback} callback Callback that handles the response.
 *
 * @async
 * @protected
 */
function requestToken(requestOptions, retryStrategy, callback) {
  emitter.emit('lockToken');
  emitter.once('unlockToken', callback);

  retryStrategy.attempts += 1;

  log(`Request: POST ${urls.getApiBaseUrl()}${requestOptions.path || ''}`);

  // eslint-disable-next-line default-param-last
  request.post(requestOptions, (error, { statusCode, headers } = {}, body) => {
    const meta = {
      request: requestOptions,
      response: {
        responseBody: body,
        statusCode,
        headers,
      },
    };
    if (error &amp;&amp; (error.message === 'ETIMEDOUT' || error.message === 'ESOCKETTIMEDOUT')) {
      if (retryStrategy.attempts >= retryStrategy.maxAttempts) {
        /*
         * If the request times out and
         * the max amount of counter.attempts has been
         * reached, pass the error to the callback
         */
        log(`Auth error: Reached maximum ${retryStrategy.maxAttempts} authentication retries`, {
          level: 'error',
          meta,
        });

        emitter.emit('unlockToken', error);
      } else {
        /*
         * If the request times out
         * and the max number of counter.attempts
         * hasn't been reached, try again
         */
        log(`Auth error: Retrying...`, { level: 'error', meta });

        emitter.removeListener('unlockToken', callback);
        requestToken(requestOptions, retryStrategy, callback);
      }
    } else if (error) {
      /*
       * If there's a programmatic error,
       * fire the callback with the error
       */
      log(`Auth error: ${error}`, { level: 'error', meta });

      emitter.emit('unlockToken', error);
    } else if (statusCode !== 200) {
      if (retryStrategy.attempts >= retryStrategy.maxAttempts) {
        /*
         * If the server returns an error and
         * the max amount of counter.attempts has been
         * reached, create an error and pass
         * it to the callback
         */
        const err = new Error();

        err.name = 'AuthenticationError';
        err.message = '';

        if (headers['www-authenticate']) {
          err.message += `${headers['www-authenticate'].match(/error_description="(.*)"/)[1]} `;
        }

        err.message += `(error ${statusCode})`;

        log(`Auth error: ${error}`, { level: 'error', meta });

        // redact &amp; filter data before passing it to the callback
        err.metaData = processLogData({ body, requestOptions });

        emitter.emit('unlockToken', err);
      } else {
        /*
         * If the server returns an error
         * and the max number of counter.attempts
         * hasn't been reached, try again
         */
        emitter.removeListener('unlockToken', callback);
        requestToken(requestOptions, retryStrategy, callback);
      }
    } else {
      /*
       * If the server returns a token,
       * set auth.token and fire the
       * callback with the new token
       */
      auth.token = {
        access_token: body.access_token,
        expires: new Date((body.created_at + body.expires_in) * 1000),
      };

      log('Success: {statusCode}\nToken: {authToken}', { data: { statusCode, authToken: auth.token } });

      emitter.emit('unlockToken', null, auth.token.access_token);
    }
  });
}

/**
 * Get authorization token.
 *
 * Repeated calls to this function mid-stream are handled gracefully in order
 * to prevent race conditions.
 *
 * @async
 *
 * @param {object} config Configuration object used by request function.
 * @param {string} config.clientId RewardOps API OAuth `client_id`.
 * @param {string} config.clientSecret RewardOps API OAuth `client_secret`.
 * @param {string} [config.timeout] Timeout for HTTP requests (used by [Request]{@link https://github.com/request/request}).
 * @param {module:api~requestCallback} callback Callback that handles the response.
 *
 * @async
 * @protected
 */
const getToken = (config, callback) => {
  /*
   * Calls to `RO.auth.getToken()` first check whether `RO.auth.tokenLocked()`
   * returns `true`. If it does, the callback passed to `RO.auth.getToken()` is
   * added as a listener to the `newToken` event.
   *
   * If it doesn't return true, call lockToken(),
   * which sets the local variable
   * `tokenLocked` to `true`. (This is read by `RO.auth.tokenLocked()`.
   * Subsequent calls then wait for the new token, per the above.)
   * Then make a call to the oauth2 server for
   * a new token as usual.
   *
   * All of this is to avoid a race condition where multiple
   * calls for a new token happen at once.
   */
  const retryStrategy = {
    attempts: 0,
    maxAttempts: 3,
  };

  if (!config.clientId || !config.clientSecret) {
    /*
     * Fire the callback with an error if the
     * config doesn't have a clientId and clientSecret
     */
    const error = new Error();

    error.name = 'AuthenticationError';
    error.message = 'You must provide a ';

    if (!config.clientId &amp;&amp; !config.clientSecret) {
      error.message += 'clientId and clientSecret';
    } else if (!config.clientId) {
      error.message += 'clientId';
    } else {
      error.message += 'clientSecret';
    }

    callback(error);
  } else if (auth.token &amp;&amp; auth.token.access_token &amp;&amp; auth.token.expires &amp;&amp; auth.token.expires > new Date()) {
    /*
     * If there's already a valid token, use it
     */
    callback(null, auth.token.access_token);
  } else if (isTokenLocked()) {
    emitter.once('unlockToken', callback);
  } else {
    /*
     * Otherwise, request a new token
     */
    const requestOptions = {
      url: config.piiServerUrl
        ? auth.getTokenUrl({ apiVersion: 'v5', apiServerUrl: config.piiServerUrl })
        : auth.getTokenUrl(config),
      json: true,
      body: {
        grant_type: 'client_credentials',
      },
      headers: generateBasicAuthToken(config.clientId, config.clientSecret),
    };

    if (config.timeout) {
      requestOptions.timeout = config.timeout;
    }

    requestToken(requestOptions, retryStrategy, callback);
  }
};

auth.getToken = getToken;

emitter.on('invalidateToken', auth.invalidateToken);
emitter.on('lockToken', lockToken);
emitter.on('unlockToken', unlockToken);

module.exports = auth;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
